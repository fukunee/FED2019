#### Q1.万物皆对象？

Q1：JS世界中，万物皆对象？
A：不尽然。要解释这个问题要理解两个原理：基本包装类型和JS内存。

1. **基本包装类型**是JS中较为特别的三个值类型：Boolean、Number、String，这三者在创建时（不论是通过字面量创建还是new操作符创建），只生成表面值供赋值与计算，不会生成其方法，此时它们不是对象。解释器在读到类似‘str1.length=1；’时会通过调用String对象的构造函数暂时性地创建一个String对象，并将1这个数值赋予该对象的length属性，改句执行完毕后随即销毁该对象，所以当下一句再执行'console.log(str1.length)'时，又会创建一个新的String对象，打印出的仍然是str1原来的长度而非1。
2. **JS内存**分为堆、栈、池。池中存放常量。程序运行的上下文是以作用域的形式保存在栈中，JS栈是一个树形的结构，程序执行时会同时存在大量的作用域，全局作用域是树的根。而在程序运行中产生的对象，则保存在堆中，作用域中保存对象的指针，JS堆则是一个扁平的结构。在基本包装类型在创建时，他们会在栈中保存他们的字面量。在调用他们的方法时会在语句执行期间在堆中短暂生成一个对象，语句结束随即销毁这个对象。

---

#### Q2.三N之惑

Q2：怎么理解undefined、null和NaN？
A：**undefined是全局常量**，名为undefined，值唯一为undefined，当它被赋予一个变量时，代表该变量待赋值，它在内存中有特殊的标志位。
**NaN是全局常量**，名为NaN，值为NaN，当它被赋予一个变量时，代表该变量不是一个数值，它在内存中有特殊的标志位。
**null不是全局常量**，当它被赋予（例如‘a=null’）一个变量时，该变量的值将变成全0的二进制值，代表该变量是一个空对象指针,它在内存中的标志位自然也是全0，所以它被机器识别为一个对象。以下对一些现象进行解释：

1. **typeof null == "object" //true**，这个语句执行时，首先在栈中临时创建了一个值null，它并没有被赋予变量；接着对其执行typeof操作，typeof操作通过判断该值的类型标志位，返回了“object”字符串，并加进了栈中；最后创建了一个字符串“object”，并对先后两个“object”字符串执行“==”操作，返回true，存入栈中，语句执行完后，将栈中没有被赋予变量的值全部销毁。
2. **null==undefined//true**，这是ECMA对“==”操作符的规定，不要从数据转换角度去理解。
3. **NaN==NaN//false NaN===NaN//false**，这是ECMA对“==”与"==="操作符的规定，NaN不会与任何值相似或相同。要判断是否一个值为NaN，直接调用全局方法isNaN(1)//false。

---

